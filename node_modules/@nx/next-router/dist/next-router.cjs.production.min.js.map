{"version":3,"file":"next-router.cjs.production.min.js","sources":["../src/utils/index.ts","../src/Route/Route.ts","../src/Router/Router.ts","../src/utils/events.ts","../src/Link/Link.tsx","../src/hocs/withNextRouter.tsx","../src/index.ts"],"sourcesContent":["export const getUrlParams = (queryString: string) => {\n  if (!queryString) {\n    return {};\n  }\n  let hashes = queryString.split('&');\n  let params: { [key: string]: string | null } = {};\n  hashes.forEach(hash => {\n    let [key, val] = hash.split('=');\n    if (key) {\n      params[key] = val ? decodeURIComponent(val) : null;\n    }\n  });\n\n  return params;\n};\n","import { PathFunction, Key, pathToRegexp, compile } from 'path-to-regexp';\nimport { getUrlParams } from './../utils';\nimport { RouteMatch } from '../types';\n\nclass Route {\n  private page: string;\n  private keys: Key[];\n  private compiled: PathFunction;\n  private regex: RegExp;\n\n  constructor(pattern: string, page: string) {\n    this.page = page;\n    this.compiled = compile(pattern, { encode: encodeURIComponent });\n    this.keys = [];\n    // @ts-ignore\n    this.regex = pathToRegexp(pattern, this.keys);\n  }\n\n  private valuesToParams(values: any, keys: Key[]) {\n    return values.reduce((params: any, val: any, i: number) => {\n      if (val === undefined) return params;\n      return Object.assign(params, {\n        [keys[i].name]: decodeURIComponent(val),\n      });\n    }, {});\n  }\n\n  match(asPath: string): RouteMatch {\n    const asPathSplitted = asPath.split('#');\n    const asPathNoHash = asPathSplitted[0];\n\n    const asPathNoHashSplitted = asPathNoHash.split('?');\n    const asPathNoHashNoQuery = asPathNoHashSplitted[0];\n\n    // get query params\n    let queryParams = {};\n    if (asPathNoHashSplitted.length > 1) {\n      queryParams = getUrlParams(asPathNoHashSplitted[1]);\n    }\n\n    // get hash\n    const hash = asPathSplitted.length > 1 ? asPathSplitted[1] : '';\n\n    const match = this.regex.exec(asPathNoHashNoQuery);\n    if (match !== null) {\n      const params = this.valuesToParams(match.slice(1), this.keys);\n      return {\n        params,\n        query: queryParams,\n        hash,\n        path: asPath,\n        page: this.page,\n        matched: true,\n      };\n    }\n    return {\n      params: {},\n      query: queryParams,\n      hash: hash,\n      path: asPath,\n      page: '',\n      matched: false,\n    };\n  }\n\n  assemble(params: any): string {\n    const compiled = this.compiled(params);\n    return compiled === '' ? '/' : compiled.replace(/%23/g, '#');\n  }\n\n  getPage(): string {\n    return this.page;\n  }\n}\n\nexport default Route;\n","import { default as NextRouter } from 'next/router';\nimport {\n  RouterMatch,\n  CurrentRoute,\n  Routes,\n  RouteAssemble,\n  LinkProps,\n} from '../types';\nimport Route from '../Route';\nimport events, { Events } from '../utils/events';\n\nclass Router {\n  private routes: { [key: string]: Route } = {};\n  private currentRoute: CurrentRoute = null;\n  public events: Events;\n\n  constructor(routes: Routes) {\n    this.setRoutes(routes);\n    this.events = events(this);\n  }\n\n  setRoutes(routes: Routes): void {\n    this.routes = {};\n    this.addRoutes(routes);\n  }\n\n  addRoutes(routes: Routes): void {\n    for (const route in routes) {\n      if (!routes.hasOwnProperty(route)) {\n        continue;\n      }\n      this.routes[route] = new Route(routes[route].pattern, routes[route].page);\n    }\n  }\n\n  getRoutes(): { [key: string]: Route } {\n    return this.routes;\n  }\n\n  match(asPath: string): RouterMatch {\n    for (const route in this.routes) {\n      if (!this.routes.hasOwnProperty(route)) {\n        continue;\n      }\n\n      const matched = this.routes[route].match(asPath);\n      if (matched.matched) {\n        return { ...matched, route };\n      }\n    }\n\n    return {\n      route: '',\n      params: {},\n      query: {},\n      path: asPath,\n      page: '',\n      hash: '',\n      matched: false,\n    };\n  }\n\n  assemble(route: string, params: any): RouteAssemble {\n    if (this.routes[route]) {\n      return {\n        path: this.routes[route].assemble(params),\n        page: this.routes[route].getPage(),\n      };\n    }\n    throw new Error('next-router: No route matched');\n  }\n\n  getLinkProps(route: string, params: any = {}, hash: string = ''): LinkProps {\n    const assembled = this.assemble(route, params);\n    const hashSuffix = hash !== '' ? `#${hash}` : '';\n    return {\n      href: { pathname: assembled.page, query: params },\n      as: `${assembled.path}${hashSuffix}`,\n    };\n  }\n\n  getLinkPropsFromHref(\n    href: string,\n    transformFn: (href: string) => string = href => href\n  ): LinkProps {\n    const hrefSlash = href.substr(0, 1) !== '/' ? `/${href}` : href;\n    const match = this.match(transformFn(hrefSlash));\n    if (match.matched) {\n      return this.getLinkProps(match.route, match.params, match.hash);\n    }\n    return {\n      href,\n      as: href,\n    };\n  }\n\n  push(\n    route: string,\n    params: any = {},\n    hash: string = '',\n    options: any = {}\n  ): Promise<boolean> {\n    const props = this.getLinkProps(route, params, hash);\n    return NextRouter.push(props.href, props.as, options);\n  }\n\n  pushHref(href: string, options: any = {}): Promise<boolean> {\n    const props = this.getLinkPropsFromHref(href);\n    return NextRouter.push(props.href, props.as, options);\n  }\n\n  replace(\n    route: string,\n    params: any = {},\n    hash: string = '',\n    options: any = {}\n  ): Promise<boolean> {\n    const props = this.getLinkProps(route, params, hash);\n    return NextRouter.replace(props.href, props.as, options);\n  }\n\n  replaceHref(href: string, options: any = {}): Promise<boolean> {\n    const props = this.getLinkPropsFromHref(href);\n    return NextRouter.replace(props.href, props.as, options);\n  }\n\n  getRequestHandler(renderFunction: Function) {\n    return (req: any, res: any, next: any) => {\n      // don't render next url's\n      const isNextUrl = req.url.match(/^\\/_next|^\\/static/);\n      if (isNextUrl) {\n        return next();\n      }\n\n      // try to match request url\n      const { matched, route, page, params, query, hash } = this.match(req.url);\n\n      if (matched) {\n        // set current route for later access\n        this.setCurrentRoute({ route, page, params, query, hash });\n\n        // call render function\n        if (renderFunction) {\n          return renderFunction(req, res, page, params, query, route);\n        }\n      }\n\n      next();\n    };\n  }\n\n  currentRouteFromMatch(routerMatch: RouterMatch): CurrentRoute {\n    const { route, page, params, query, hash } = routerMatch;\n    return {\n      route,\n      page,\n      params,\n      query,\n      hash,\n    };\n  }\n\n  setCurrentRoute(currentRoute: CurrentRoute) {\n    this.currentRoute = currentRoute;\n  }\n\n  getCurrentRoute(): CurrentRoute {\n    return this.currentRoute;\n  }\n}\n\nexport default Router;\n","import { default as NextRouter } from 'next/router';\nimport Router from 'Router/Router';\n\ntype Handler = (...evts: any[]) => void;\n\nexport type EventType =\n  | 'routeChangeStart'\n  | 'beforeHistoryChange'\n  | 'routeChangeComplete'\n  | 'routeChangeError'\n  | 'hashChangeStart'\n  | 'hashChangeComplete';\n\nexport type Events = {\n  on(type: EventType, handler: Handler): void;\n  off(type: EventType, handler: Handler): void;\n};\n\ntype Handlers = { handler: Handler; handlerRouter: Handler };\n\ntype Cache = { [s: string]: Handlers[] };\n\nconst getHandlerRouter = (router: Router, handler: Handler) => (\n  ...evts: any[]\n) => {\n  let url = evts[0];\n  if (evts.length > 1 && typeof evts[1] === 'string') {\n    url = evts[1];\n  }\n  const routerMatch = router.match(url);\n  const currentRoute = router.currentRouteFromMatch(routerMatch);\n  if (evts.length === 1) {\n    handler(currentRoute);\n  } else {\n    handler(evts[0], currentRoute);\n  }\n};\n\nconst findHandlersIndex = (arr: Handlers[], handler: Handler) => {\n  return arr.findIndex(handlers => {\n    return handlers.handler === handler;\n  });\n};\n\nexport default function events(router: Router): Events {\n  const all: Cache = Object.create(null);\n\n  return {\n    on(type: EventType, handler: Handler) {\n      const handlerRouter = getHandlerRouter(router, handler);\n      NextRouter.events.on(type, handlerRouter);\n      (all[type] || (all[type] = [])).push({ handler, handlerRouter });\n    },\n    off(type: EventType, handler: Handler) {\n      if (all[type]) {\n        const handlersIndex = findHandlersIndex(all[type], handler);\n        if (handlersIndex >= 0) {\n          const handlerRouter = all[type][handlersIndex].handlerRouter;\n          NextRouter.events.off(type, handlerRouter);\n          all[type].splice(handlersIndex, 1);\n        }\n      }\n    },\n  };\n}\n","import * as React from 'react';\nimport NextLink from 'next/link';\nimport Router from '../Router';\n\nexport type LinkProps = {\n  route?: string;\n  params?: any;\n  hash?: string;\n  href?: string;\n  children: React.ReactElement<any>;\n  [key: string]: any;\n};\n\nconst Link = (router: Router) => ({\n  route,\n  params = {},\n  hash = '',\n  href,\n  children,\n  ...props\n}: LinkProps) => {\n  if (!route && !href) {\n    throw new Error(\n      'next-router: You have to provide a route or a href to the Link'\n    );\n  }\n\n  let mergedProps;\n\n  if (route) {\n    mergedProps = { ...router.getLinkProps(route, params, hash), ...props };\n  } else {\n    mergedProps = { ...router.getLinkPropsFromHref(href || ''), ...props };\n  }\n\n  return <NextLink {...mergedProps}>{children}</NextLink>;\n};\n\nexport default Link;\n","import * as React from 'react';\nimport { NextComponentType } from 'next';\nimport { AppContext } from 'next/app';\nimport Router from './../Router';\nimport { CurrentRoute, RouterMatch } from './../types';\n\ninterface WrappedAppProps {\n  initialProps: any;\n  nextRouter_currentRoute: CurrentRoute;\n}\n\nconst getRouterMatch = (appCtx: AppContext, router: Router): RouterMatch => {\n  const asPath = appCtx.ctx.asPath || '';\n  return router.match(asPath);\n};\n\nexport default (\n  router: Router,\n  getRouterMatchFunction?: (appCtx: AppContext, router: Router) => RouterMatch\n) => {\n  if (!getRouterMatchFunction) {\n    getRouterMatchFunction = getRouterMatch;\n  }\n\n  return (App: NextComponentType | any) =>\n    class WrappedApp extends React.Component<WrappedAppProps> {\n      public static getInitialProps = async (appCtx: AppContext) => {\n        let initialProps = {};\n\n        let routerMatch: RouterMatch = {\n          route: '',\n          params: {},\n          query: {},\n          path: '',\n          page: '',\n          hash: '',\n          matched: false,\n        };\n\n        if (getRouterMatchFunction) {\n          routerMatch = getRouterMatchFunction(appCtx, router);\n        }\n\n        if (!routerMatch.matched) {\n          if (appCtx.ctx.res) {\n            appCtx.ctx.res.statusCode = 404;\n          }\n        }\n\n        const { route, page, params, query, hash } = routerMatch;\n        const nextRouter_currentRoute = { route, page, params, query, hash };\n        router.setCurrentRoute(nextRouter_currentRoute);\n\n        appCtx.ctx.query = { ...query, ...params };\n\n        if ('getInitialProps' in App) {\n          initialProps = await App.getInitialProps.call(App, appCtx);\n        }\n\n        return {\n          nextRouter_currentRoute,\n          initialProps,\n        };\n      };\n\n      public render() {\n        const { initialProps, nextRouter_currentRoute, ...props } = this.props;\n\n        // set current route on hydration\n        if (!router.getCurrentRoute()) {\n          router.setCurrentRoute(nextRouter_currentRoute);\n        }\n\n        return <App {...props} {...initialProps} />;\n      }\n    };\n};\n","import NextLink from 'next/link';\nimport Router from './Router';\nimport Link from './Link';\nimport withNextRouterFactory from './hocs/withNextRouter';\nimport { CurrentRoute, RouterMatch, Routes } from './types';\nimport { AppContext } from 'next/app';\n\nlet router: Router;\nlet link;\nlet withNextRouter;\n\ninterface Constructable<T> {\n  new (routes: Routes): T;\n}\n\nexport const init = (\n  routes: Routes,\n  RouterClass?: Constructable<Router>,\n  LinkFactory?: (router: Router) => typeof NextLink,\n  getRouterMatchFunction?: (appCtx: AppContext, router: Router) => RouterMatch\n) => {\n  router = RouterClass ? new RouterClass(routes) : new Router(routes);\n  link = LinkFactory ? LinkFactory(router) : Link(router);\n  withNextRouter = withNextRouterFactory(router, getRouterMatchFunction);\n};\n\nconst useRouter = (): CurrentRoute => {\n  if (!router) {\n    throw new Error(\n      'next-router: Router is not set. You have to initialize next-router first.'\n    );\n  }\n  return router.getCurrentRoute();\n};\n\nexport { Router as RouterClass, Link as LinkFactory, withNextRouterFactory };\nexport { router as Router };\nexport { link as Link };\nexport { withNextRouter, useRouter };\nexport { default as RouteClass } from './Route';\nexport {\n  Routes,\n  RouteMatch,\n  RouteAssemble,\n  LinkProps,\n  CurrentRoute,\n} from './types';\n"],"names":["Route","pattern","page","compiled","compile","encode","encodeURIComponent","keys","regex","pathToRegexp","this","valuesToParams","values","reduce","params","val","i","undefined","Object","assign","name","decodeURIComponent","match","asPath","asPathSplitted","split","asPathNoHashSplitted","asPathNoHashNoQuery","queryParams","length","queryString","hashes","forEach","hash","key","getUrlParams","exec","slice","query","path","matched","assemble","replace","getPage","Router","routes","router","all","setRoutes","events","create","on","type","handler","handlerRouter","url","arguments","routerMatch","currentRoute","currentRouteFromMatch","getHandlerRouter","NextRouter","push","off","handlersIndex","arr","findIndex","handlers","findHandlersIndex","splice","addRoutes","route","hasOwnProperty","getRoutes","Error","getLinkProps","assembled","href","pathname","as","getLinkPropsFromHref","transformFn","hrefSlash","substr","options","props","pushHref","replaceHref","getRequestHandler","renderFunction","req","res","next","_this","setCurrentRoute","getCurrentRoute","Link","mergedProps","children","React","NextLink","getRouterMatch","appCtx","ctx","getRouterMatchFunction","App","render","initialProps","nextRouter_currentRoute","statusCode","getInitialProps","call","RouterClass","LinkFactory","link","withNextRouter","withNextRouterFactory"],"mappings":"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"}